<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html><head><link rel="stylesheet" href="sitewide.css" type="text/css"><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"/><meta name="exporter-version" content="Evernote Mac 7.5.2 (457164)"/><meta name="altitude" content="-3.952529907226562"/><meta name="author" content="Alex Balgavy"/><meta name="created" content="2018-10-21 14:20:16 +0000"/><meta name="latitude" content="52.30026245117188"/><meta name="longitude" content="4.988008741950571"/><meta name="source" content="desktop.mac"/><meta name="updated" content="2018-10-22 19:03:21 +0000"/><title>Hashing</title></head><body><ul><li><div>hash tables are good for dictionaries</div></li><li><div>keys starting at 0</div></li><li><div>direct address table:</div></li><div style="margin-left: 40px;"><span style="font-size: 16px;">
<img src="Hashing.resources/222686E3-E597-448C-813E-19F3D3B4797C.png" height="16" width="133"/><br/></span></div><div style="margin-left: 40px;"/><div style="margin-left: 40px;"><span style="font-size: 16px;">
<img src="Hashing.resources/ED0C65BF-2D0C-47DB-85AD-D564352E2179.png" height="50" width="433"/><br/></span></div><ul><li><div>insert: set value at key</div></li><li><div>delete: set value to nil</div></li><li><div>drawbacks: lots of memory, keys must be int</div></li><li><div>identity function key —&gt; index</div></li></ul><li><div>for other purposes, change the mapping function</div></li><li><div>simple example:</div></li><ul><li><div>keys are first names, value phone number</div></li><li><div>hash function is name length mod 5</div></li></ul><li><div>choosing a hash function</div></li><ul><li><div>division: k ➝ (k mod m)</div></li><ul><li><div>easy but not good for all values</div></li><li><div>so better to take prime not close to power of 2</div></li></ul><li><div>multiplication</div></li></ul><li><div>problem of collision: different keys hashed to same slot</div></li><ul><li><div>for p items, hash table size m, so m<span style="vertical-align: super;">p</span> possibilities for hash function</div></li><li><div><span style="font-size: 16px;"
/><img src="Hashing.resources/B338CD36-2860-4592-99BB-3FA494E7B88F.png" height="39" width="59"/><span style="font-size: 16px;"> </span>possibilities for hashing without collision</div></li></ul><li><div>solving collisions</div></li><ul><li><div>chaining: put items that hash to same value in a linked list</div></li><ul><li><div>insertion in O(1)</div></li><li><div>deletion in O(1) for doubly-linked (you wouldn’t use singly linked)</div></li><li><div>searching in O(n) with n dictionary size, average in ϴ(1+α)</div></li><ul><li><div>α is load factor</div></li><li><div>for n keys, m slots,</div><div><span style="font-size: 16px;">
<img src="Hashing.resources/6CEC6A12-FEFA-4B86-88B7-554DC3904474.png" height="31" width="48"/></span></div></li></ul></ul><li><div>open addressing</div></li><ul><li><div>make probe sequence: h: U × { 0…m-1} ➝ {0…m-1}</div></li><li><div>linear probing</div></li><ul><li><div>for next probe, next address mod m</div></li><li><div>h(k,i) = h’(k) + i mod m</div></li><li><div>keep increasing i until empty place found</div></li><li><div>but you get clustering, and removal hurts on a physical level</div></li></ul><li><div>double hashing, use two functions when the first function gives a collision</div></li></ul></ul></ul><div><br/></div></body></html>